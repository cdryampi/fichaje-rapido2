{% extends "base.html" %}

{% block content %}
<section class="pdf-page">
  <div class="header">
    <h2>Visor de PDF</h2>
    <p class="muted">Sube un documento PDF y visualizalo al instante sin salir de la aplicacion.</p>
  </div>
  <div class="layout">
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <section class="card pdf-uploader">
      <h3>Selecciona un archivo</h3>
      <p class="muted">Solo se admiten archivos en formato PDF. El documento se carga de forma local en tu navegador.
      </p>
      <label class="file-picker">
        <input type="file" id="pdf-file-input" accept="application/pdf" />
        <span class="file-picker__hint">
          <i data-lucide="file-input" class="icon"></i>
          <span data-file-name>Selecciona un PDF desde tu equipo</span>
        </span>
      </label>
      <button type="button" class="btn btn-green" id="load-pdf-button">
        <i data-lucide="upload-cloud" class="icon"></i>
        Cargar PDF
      </button>
      <button type="button" class="btn btn-yellow detect-btn" id="detect-sensitive-button">
        <i data-lucide="shield-alert" class="icon"></i>
        Detectar datos sensibles
      </button>
      <button type="button" class="btn btn-red detect-btn" id="obfuscate-sensitive-button" disabled>
        <i data-lucide="eye-off" class="icon"></i>
        Emborronar datos sensibles
      </button>
      <button type="button" class="btn btn-outline detect-btn" id="save-redacted-button" disabled
        style="margin-top: 6px;">
        <i data-lucide="download" class="icon"></i>
        Guardar PDF Censurado
      </button>
      <div class="detection-panel" data-detection-output>
        <h4>Resultados del analisis</h4>
        <p class="muted small" data-detection-summary>No se ha analizado ningun PDF todavia.</p>

        <!-- Filters -->
        <div class="filter-controls is-hidden" id="confidence-filters" style="margin-bottom: 8px;">
          <span style="font-size: 11px; margin-right: 4px; color: #94a3b8;">Filtrar por confianza:</span>
          <button type="button" class="btn-xs btn-active" data-filter="all">Todas</button>
          <button type="button" class="btn-xs" data-filter="high">Alta</button>
          <button type="button" class="btn-xs" data-filter="medium">Media+</button>
        </div>

        <div class="detection-controls is-hidden" data-select-all-container>
          <label class="detection-checkbox-label">
            <input type="checkbox" id="sensitive-select-all" />
            <span>Seleccionar/deseleccionar todos</span>
          </label>
        </div>
        <ul class="detection-list" data-detection-list></ul>

        <!-- Debug Section -->
        <details class="debug-details" data-debug-container
          style="display: none; margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px;">
          <summary style="cursor: pointer; font-size: 12px; color: #94a3b8; user-select: none;">Ver depuracion AI
          </summary>
          <div data-debug-content
            style="margin-top: 8px; font-family: monospace; font-size: 11px; white-space: pre-wrap; color: #cbd5e1; max-height: 300px; overflow-y: auto;">
          </div>
        </details>
      </div>
      <p class="muted small">El PDF no se guarda en el servidor; se muestra solo para ti.</p>
    </section>
    <section class="card pdf-viewer">
      <h3>Vista previa 2</h3>
      <div class="pdf-viewer__frame" data-pdf-container>
        <div class="pdf-placeholder" data-pdf-placeholder>
          <i data-lucide="file-text" class="icon"></i>
          <p class="muted">Sube un PDF y pulsa "Cargar PDF" para visualizarlo.</p>
        </div>
        <div class="pdf-renderer" data-pdf-renderer style="display:none"></div>
        <object data="" type="application/pdf" class="pdf-native-viewer" data-pdf-native
          style="display:none; width:100%; height:100%; border:none;"></object>
      </div>
    </section>
  </div>
</section>
<style>
  .pdf-page {
    display: flex;
    flex-direction: column;
    gap: 16px
  }

  .pdf-layout {
    display: flex;
    flex-direction: column;
    gap: 16px
  }

  .pdf-page .card {
    max-width: none;
    width: 100%
  }

  .pdf-uploader {
    flex: 0 0 auto;
    width: 100%
  }

  .pdf-viewer {
    flex: 1 1 auto;
    min-width: 0
  }

  .pdf-uploader h3,
  .pdf-viewer h3 {
    margin-top: 0;
    margin-bottom: 12px
  }

  .pdf-viewer__frame {
    position: relative;
    height: 85vh;
    min-height: 720px;
    border: 1px dashed #d0d0d0;
    border-radius: 12px;
    overflow: hidden;
    background: #fafafa;
    width: 100%
  }

  .pdf-placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 24px;
    color: #666
  }

  .pdf-placeholder .icon {
    width: 36px;
    height: 36px
  }

  .pdf-placeholder.is-hidden {
    display: none
  }

  .pdf-renderer {
    display: none;
  }



  .file-picker {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 16px;
    border: 1px dashed #bbb;
    border-radius: 12px;
    background: #fff;
    cursor: pointer;
    transition: border-color .2s ease, background-color .2s ease
  }

  .file-picker:hover {
    border-color: #888;
    background: #f5f5f5
  }

  .file-picker input {
    display: none
  }

  .file-picker__hint {
    display: flex;
    gap: 10px;
    align-items: center;
    color: #333;
    font-weight: 600
  }

  .file-picker__hint .icon {
    width: 20px;
    height: 20px
  }

  .muted.small {
    font-size: 13px
  }

  .detect-btn {
    margin-top: 6px;
    width: 100%;
    justify-content: center
  }

  .detection-panel {
    margin-top: 14px;
    padding: 16px;
    border: 1px solid #1f2937;
    border-radius: 10px;
    background: #1e293b;
    color: #e2e8f0;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 12px 30px rgba(15, 23, 42, .35)
  }

  .detection-panel h4 {
    margin: 0;
    font-size: 15px;
    color: #f1f5f9
  }

  .detection-controls {
    display: flex;
    justify-content: flex-end
  }

  .detection-controls.is-hidden {
    display: none
  }

  .detection-checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: inherit;
    cursor: pointer
  }

  .detection-checkbox-label input {
    width: 16px;
    height: 16px
  }

  .detection-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 6px
  }

  .detection-list li {
    padding: 10px 12px;
    border-radius: 8px;
    background: rgba(255, 255, 255, .08);
    border: 1px solid rgba(148, 163, 184, .4);
    font-size: 14px;
    line-height: 1.5;
    color: #f8fafc
  }

  .detection-item {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    gap: 10px
  }

  .detection-values {
    display: flex;
    flex-direction: column;
    gap: 6px;
    flex: 1
  }

  .detection-option {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    color: inherit;
    cursor: pointer;
    flex: 1
  }

  .detection-option input {
    margin-top: 2px;
    flex: 0 0 auto
  }

  .detection-option span {
    display: block;
    color: inherit;
    flex: 1
  }

  .detection-tag {
    display: inline-block;
    padding: 3px 8px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    background: #475569;
    color: #f8fafc;
    border-radius: 4px;
    margin-right: 6px
  }

  /* Filters */
  .filter-controls.is-hidden {
    display: none;
  }

  .btn-xs {
    padding: 2px 8px;
    font-size: 11px;
    border-radius: 4px;
    border: 1px solid #475569;
    background: transparent;
    color: #cbd5e1;
    cursor: pointer;
    margin-right: 4px;
  }

  .btn-xs:hover {
    background: #334155;
  }

  .btn-xs.btn-active {
    background: #3b82f6;
    border-color: #3b82f6;
    color: white;
  }



  .detection-empty {
    color: #cbd5f5;
    font-style: italic
  }

  .detection-reason {
    margin-top: 4px;
    font-size: 12px;
    color: #cbd5f5
  }

  .dark .detection-panel {
    background: #111827;
    border-color: #334155;
    color: #e2e8f0;
    box-shadow: 0 12px 30px rgba(2, 6, 23, .6)
  }

  .dark .detection-panel h4 {
    color: #f8fafc
  }

  .dark .detection-list li {
    background: rgba(148, 163, 184, .12);
    border-color: rgba(148, 163, 184, .35)
  }

  .dark .detection-empty {
    color: #94a3b8
  }

  .dark .detection-reason {
    color: #cbd5f5
  }

  .dark .pdf-redaction::after {
    background: rgba(2, 6, 23, .92)
  }

  @media (min-width:900px) {
    .pdf-layout {
      flex-direction: row;
      align-items: flex-start;
      gap: 24px
    }

    .pdf-uploader {
      flex: 0 0 360px;
      max-width: 360px
    }
  }
</style>
<script>
  (function () {
    var PDFJS_SRC = "{{ url_for('static', filename='vendor/pdfjs/pdf.min.js') }}";
    var PDFJS_WORKER_SRC = "{{ url_for('static', filename='vendor/pdfjs/pdf.worker.min.js') }}";
    var PDFJS_FALLBACK_SRC = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
    var PDFJS_FALLBACK_WORKER_SRC = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    var fileInput = document.getElementById("pdf-file-input");
    var loadButton = document.getElementById("load-pdf-button");
    var detectButton = document.getElementById("detect-sensitive-button");
    var obfuscateButton = document.getElementById("obfuscate-sensitive-button");
    var fileNameTarget = document.querySelector("[data-file-name]");
    var renderer = document.querySelector("[data-pdf-renderer]");
    var nativeViewer = document.querySelector("[data-pdf-native]");
    var placeholder = document.querySelector("[data-pdf-placeholder]");
    var container = document.querySelector("[data-pdf-container]");
    var detectionSummary = document.querySelector("[data-detection-summary]");
    var detectionList = document.querySelector("[data-detection-list]");
    var selectAllCheckbox = document.getElementById("sensitive-select-all");
    var selectAllContainer = document.querySelector("[data-select-all-container]");
    var debugContainer = document.querySelector("[data-debug-container]");
    var debugContent = document.querySelector("[data-debug-content]");
    var csrfMeta = document.querySelector('meta[name="csrf-token"]');
    if (!fileInput || !loadButton || !renderer || !container || !detectButton || !obfuscateButton || !detectionSummary || !detectionList || !selectAllCheckbox || !selectAllContainer) { return; }

    var pdfLoaderPromise = null;
    var activeWorkerSrc = PDFJS_WORKER_SRC;
    var currentPdfBytes = null;
    var currentPdfDoc = null;
    var renderedPages = [];
    var latestFindings = null;
    var documentFullText = "";
    var selectionState = Object.create(null);
    var activeRedactions = [];

    fileInput.addEventListener("change", function () {
      if (fileNameTarget) {
        var file = fileInput.files && fileInput.files[0];
        fileNameTarget.textContent = file ? file.name : "Selecciona un PDF desde tu equipo";
      }
      detectionSummary.textContent = "No se ha analizado ningun PDF todavia.";
      detectionList.innerHTML = "";
      latestFindings = null;
      documentFullText = "";
      activeRedactions = [];
      clearSelections();
      showSelectAllControls(false);
      showDebugInfo(null);
      obfuscateButton.disabled = true;
    });

    loadButton.addEventListener("click", function () {
      var file = fileInput.files && fileInput.files[0];
      if (!file) {
        alert("Selecciona un archivo PDF antes de cargarlo.");
        return;
      }
      if (!isPdfFile(file)) {
        alert("El archivo seleccionado debe ser un PDF.");
        return;
      }
      loadButton.blur();
      clearSelections();
      showSelectAllControls(false);
      showDebugInfo(null);
      obfuscateButton.disabled = true;
      activeRedactions = [];
      detectionSummary.textContent = "Renderizando PDF...";
      detectionList.innerHTML = "";
      container.classList.add("has-file");
      if (placeholder) {
        placeholder.classList.add("is-hidden");
      }
      documentFullText = "";
      latestFindings = null;
      applyHighlights(null);
      readFileAsArrayBuffer(file)
        .then(function (uint8) {
          // CLONE the data for local storage, because passing 'uint8' to PDF.js
          // (especially in worker mode) might transfer/detach the buffer.
          currentPdfBytes = uint8.slice(0); // Deep copy

          applyHighlights(null);
          if (nativeViewer) {
            var blob = new Blob([currentPdfBytes], { type: 'application/pdf' });
            var url = URL.createObjectURL(blob);
            nativeViewer.data = url;
            nativeViewer.style.display = 'block';
            if (placeholder) placeholder.style.display = 'none';
          }
          return ensurePdfJs().then(function (pdfjs) {
            return pdfjs.getDocument({ data: uint8 }).promise.then(function (doc) {
              currentPdfDoc = doc;
              return doc;
            });
          });
        })
        .then(function () {
          detectionSummary.textContent = "El PDF esta listo para analizar. Los hallazgos se resaltaran en amarillo.";
          detectionList.innerHTML = '<li class="detection-empty">Pulsa "Detectar datos sensibles" para iniciar el analisis.</li>';
        })
        .catch(function (err) {
          console.error(err);
          detectionSummary.textContent = "No se pudo mostrar el PDF (" + (err && err.message ? err.message : "error desconocido") + ").";
          detectionList.innerHTML = '<li class="detection-empty">Intenta cargar el documento de nuevo.</li>';
          resetViewer();
        });
    });

    detectButton.addEventListener("click", function () {
      var file = fileInput.files && fileInput.files[0];
      if (!file) {
        alert("Selecciona un archivo PDF antes de analizarlo.");
        return;
      }
      if (!isPdfFile(file)) {
        alert("El archivo seleccionado debe ser un PDF.");
        return;
      }
      detectButton.disabled = true;
      clearSelections();
      showSelectAllControls(false);
      showDebugInfo(null);
      obfuscateButton.disabled = true;
      activeRedactions = [];
      detectionSummary.textContent = "Analizando PDF en busca de datos sensibles...";
      detectionList.innerHTML = "";

      var analysisPromise = currentPdfBytes
        ? Promise.resolve(currentPdfBytes)
        : readFileAsArrayBuffer(file).then(function (uint8) {
          currentPdfBytes = uint8;
          return uint8;
        });

      analysisPromise
        .then(function (bytes) {
          return ensurePdfJs().then(function (pdfjs) {
            var docPromise = currentPdfDoc
              ? Promise.resolve(currentPdfDoc)
              : pdfjs.getDocument({ data: bytes }).promise.then(function (doc) {
                currentPdfDoc = doc;
                return doc;
              });
            return docPromise.then(function (pdfDoc) {
              var textPromises = [];
              for (var i = 1; i <= pdfDoc.numPages; i++) {
                textPromises.push(
                  pdfDoc.getPage(i).then(function (page) {
                    return page.getTextContent().then(function (content) {
                      return content.items.map(function (item) { return item.str; }).join(" ");
                    });
                  })
                );
              }
              return Promise.all(textPromises).then(function (pages) {
                return pages.join("\n");
              });
            });
          });
        })
        .then(function (fullText) {
          documentFullText = fullText || "";
          return processSensitiveData(documentFullText);
        })
        .catch(function (err) {
          console.error(err);
          var message = err && err.message ? err.message : "Hubo un problema analizando el PDF.";
          detectionSummary.textContent = message;
          activeRedactions = [];
          clearSelections();
          showSelectAllControls(false);
          obfuscateButton.disabled = true;
          applyHighlights(null);
          if (!detectionList.innerHTML) {
            detectionList.innerHTML = '<li class="detection-empty">No fue posible analizar el documento.</li>';
          }
        })
        .finally(function () {
          detectButton.disabled = false;
        });
    });

    // Se usa para almacenar el blob de previsualización (censurado)
    var currentRedactedBlobUrl = null;

    obfuscateButton.addEventListener("click", function () {
      if (!latestFindings || !latestFindings.length) {
        alert("Detecta los datos sensibles antes de emborronarlos.");
        return;
      }
      var selectedValues = getSelectedValues();
      obfuscateButton.blur();

      // GENERAR PREVIEW
      if (!currentPdfBytes) {
        alert("No hay PDF cargado.");
        return;
      }

      detectionSummary.textContent = "Generando previsualización censurada...";

      generateRedactedPdfBytes(currentPdfBytes, latestFindings, selectedValues)
        .then(function (redactedBytes) {
          if (!redactedBytes) return; // Error handled inside

          // Actualizar el visor nativo con el nuevo PDF
          var blob = new Blob([redactedBytes], { type: 'application/pdf' });
          if (currentRedactedBlobUrl) {
            window.URL.revokeObjectURL(currentRedactedBlobUrl);
          }
          currentRedactedBlobUrl = window.URL.createObjectURL(blob);

          if (nativeViewer) {
            nativeViewer.data = currentRedactedBlobUrl;
          }

          var baseMessage = "Se ocultaron " + selectedValues.length + " datos sensibles. Previsualización actualizada.";
          if (detectionSummary) {
            detectionSummary.textContent = baseMessage;
            detectionSummary.dataset.baseMessage = baseMessage;
          }

          // Habilitar guardar
          var saveButton = document.getElementById("save-redacted-button");
          if (saveButton) {
            saveButton.disabled = false;
          }
        });
    });

    var saveButton = document.getElementById("save-redacted-button");
    if (saveButton) {
      saveButton.addEventListener("click", function () {
        var selectedValues = getSelectedValues();

        if (!selectedValues.length) {
          alert("Primero debes emborronar algo para poder guardar.");
          return;
        }
        if (!currentPdfBytes) {
          alert("No hay PDF cargado.");
          return;
        }

        // Deshabilitar botón durante proceso
        saveButton.disabled = true;
        var originalText = saveButton.innerHTML;
        saveButton.innerHTML = 'Procesando...';

        calculateRedactionCoordinates(currentPdfBytes, selectedValues)
          .then(function (redactions) {
            if (!redactions || !redactions.length) {
              alert("No se encontraron coincidencias para los términos seleccionados.");
              saveButton.disabled = false;
              saveButton.innerHTML = originalText;
              return;
            }

            var formData = new FormData();
            var blob = new Blob([currentPdfBytes], { type: "application/pdf" });
            formData.append("file", blob, "original.pdf");
            formData.append("redactions", JSON.stringify(redactions));

            var csrf = getCsrfToken();

            fetch("/api/pdf/redact", {
              method: "POST",
              headers: { "X-CSRFToken": csrf },
              body: formData
            })
              .then(function (res) {
                if (res.status === 501) {
                  throw new Error("El servidor no tiene instalada la librería de seguridad (PyMuPDF). Instala 'pymupdf' con pip.");
                }
                if (!res.ok) {
                  return res.json().then(function (d) { throw new Error(d.error || "Error en servidor"); });
                }
                return res.blob();
              })
              .then(function (blob) {
                downloadBlob(blob, "documento_censurado_seguro.pdf", "application/pdf");
              })
              .catch(function (err) {
                console.error(err);
                alert("Error guardando PDF: " + err.message);
              })
              .finally(function () {
                saveButton.disabled = false;
                saveButton.innerHTML = originalText;
              });
          });
      });
    }

    async function calculateRedactionCoordinates(pdfBytes, redactionTerms) {
      if (!window.PDFLib) return [];

      try {
        var pdfCopy = new Uint8Array(pdfBytes);
        var pdfDoc = await PDFLib.PDFDocument.load(pdfCopy, { ignoreEncryption: true });
        var pages = pdfDoc.getPages();
        var redactedRects = [];

        if (!currentPdfDoc) return [];

        for (var pgIdx = 0; pgIdx < pages.length; pgIdx++) {
          var pdfJsPage = await currentPdfDoc.getPage(pgIdx + 1);
          var textContent = await pdfJsPage.getTextContent();

          for (var item of textContent.items) {
            var text = item.str;
            if (!text) continue;
            var shouldRedact = false;
            for (var term of redactionTerms) {
              if (normalizeTerm(text).includes(normalizeTerm(term))) {
                shouldRedact = true;
                break;
              }
            }
            if (shouldRedact) {
              // PDF Layout:
              // item.transform -> [scaleX, skewY, skewX, scaleY, tx, ty]
              // Width/Height logic similar to pdf_tool logic
              var tx = item.transform[4];
              var ty = item.transform[5];
              var itemWidth = item.width || 0;
              var fontSize = Math.sqrt(item.transform[0] * item.transform[0] + item.transform[1] * item.transform[1]);

              // Backend (PyMuPDF) expects: page (1-based), x, y, width, height.
              // Coordinate system: PDF standard (bottom-left origin usually, but fitz handles internal?)
              // PyMuPDF fitz.Rect(x0, y0, x1, y1).
              // Actually PDF uses bottom-up Y, but pdf.js and fitz text extraction often normalize.
              // However, drawing rectangles in PyMuPDF (add_redact_annot) works with Top-Left origin usually if using normal coordinates?
              // Wait, typical PDF is bottom-left origin.
              // Let's pass the raw PDF coordinates we get from pdf.js.
              // pdf.js text items are in PDF user space.
              // PyMuPDF expects rect in PDF user space.
              // One catch: item.transform[5] (ty) is the baseline. We need the "top" of the text box?
              // Or bottom?
              // The regex box drawing in generateRedactedPdfBytes used (tx, ty, width, height).
              // Let's verify how it was doing it:
              // page.drawRectangle({ x: tx, y: ty, ... }) -> pdf-lib uses bottom-left origin.
              // So tx, ty is the bottom-left corner of the text?
              // Ideally yes.

              redactedRects.push({
                page: pgIdx + 1,
                x: tx,
                y: ty,
                width: itemWidth,
                height: fontSize
              });
            }
          }
        }
        return redactedRects;
      } catch (e) {
        console.error("Error calc coords", e);
        return [];
      }
    }

    async function generateRedactedPdfBytes(pdfBytes, findings, redactionTerms) {
      if (!window.PDFLib) {
        alert("La librería PDF-Lib no se ha cargado correctamente.");
        return null;
      }

      // DEBUG: Verificar entrada
      try {
        if (pdfBytes && pdfBytes.length > 4) {
          var header = String.fromCharCode(pdfBytes[0], pdfBytes[1], pdfBytes[2], pdfBytes[3]);
          if (header !== "%PDF") {
            console.error("Invalid PDF Header:", header);
            alert("El archivo en memoria no parece ser un PDF válido. Intenta recargar.");
            return null;
          }
        }
      } catch (e) {
        console.error("Debug Error:", e);
      }

      try {
        // Clonamos para evitar problemas de referencia o modificación
        var pdfCopy = new Uint8Array(pdfBytes);
        var pdfDoc = await PDFLib.PDFDocument.load(pdfCopy, { ignoreEncryption: true });
        var pages = pdfDoc.getPages();

        if (!currentPdfDoc) {
          alert("Error interno: documento PDF.js no disponible.");
          return null;
        }

        for (var pgIdx = 0; pgIdx < pages.length; pgIdx++) {
          var page = pages[pgIdx];
          var pdfJsPage = await currentPdfDoc.getPage(pgIdx + 1); // 1-based
          var textContent = await pdfJsPage.getTextContent();

          for (var item of textContent.items) {
            var text = item.str;
            if (!text) continue;

            var shouldRedact = false;
            for (var term of redactionTerms) {
              if (normalizeTerm(text).includes(normalizeTerm(term))) {
                shouldRedact = true;
                break;
              }
            }

            if (shouldRedact) {
              var tx = item.transform[4];
              var ty = item.transform[5];
              var itemWidth = item.width || 0;
              var fontSize = Math.sqrt(item.transform[0] * item.transform[0] + item.transform[1] * item.transform[1]);

              page.drawRectangle({
                x: tx,
                y: ty,
                width: itemWidth,
                height: fontSize,
                color: PDFLib.rgb(0, 0, 0),
                opacity: 1,
              });
            }
          }
        }

        var pdfBytesModified = await pdfDoc.save();
        return pdfBytesModified;

      } catch (e) {
        console.error(e);
        alert("Error generando PDF censurado: " + e.message);
        return null;
      }
    }

    function downloadBlob(data, fileName, mimeType) {
      var blob = new Blob([data], { type: mimeType });
      var url = window.URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.style.display = "none";
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }

    detectionList.addEventListener("change", function (event) {
      var target = event.target;
      if (!target || !target.matches('input[data-entry-key]')) { return; }
      var key = target.getAttribute("data-entry-key");
      if (!key) { return; }
      var entry = selectionState[key];
      if (!entry) {
        var decoded = decodeEntryKey(key);
        selectionState[key] = {
          label: decoded.label || "",
          value: (decoded.value || "").trim(),
          selected: target.checked
        };
      } else {
        entry.selected = target.checked;
      }
      updateSelectAllUi();
      if (detectionSummary && detectionSummary.dataset && detectionSummary.dataset.baseMessage) {
        detectionSummary.textContent = detectionSummary.dataset.baseMessage;
      }
    });

    selectAllCheckbox.addEventListener("change", function () {
      var checked = !!selectAllCheckbox.checked;
      var keys = Object.keys(selectionState);
      if (keys.length) {
        keys.forEach(function (key) {
          if (!selectionState[key]) { return; }
          selectionState[key].selected = checked;
        });
      }
      detectionList.querySelectorAll('input[data-entry-key]').forEach(function (input) {
        input.checked = checked;
      });
      selectAllCheckbox.indeterminate = false;
      if (detectionSummary && detectionSummary.dataset && detectionSummary.dataset.baseMessage) {
        detectionSummary.textContent = detectionSummary.dataset.baseMessage;
      }
    });

    window.addEventListener("beforeunload", destroyCurrentPdf);

    function processSensitiveData(fullText) {
      var groups = collectCandidateGroups(fullText);
      if (!groups.length) {
        detectionSummary.textContent = "No se detectaron patrones sensibles evidentes.";
        detectionList.innerHTML = '<li class="detection-empty">Sin coincidencias.</li>';
        applyHighlights(null);
        activeRedactions = [];
        clearSelections();
        showSelectAllControls(false);
        showDebugInfo(null);
        obfuscateButton.disabled = true;
        return Promise.resolve();
      }
      detectionSummary.textContent = "Validando coincidencias con IA...";
      detectionList.innerHTML = '<li class="detection-empty">Esperando validacion de IA...</li>';
      return callAiValidation(fullText, groups)
        .then(function (aiData) {
          if (aiData && aiData.debug) {
            showDebugInfo(aiData.debug);
          }
          if (aiData && aiData.sensitive && aiData.sensitive.length) {
            var grouped = groupByLabel(aiData.sensitive);
            prepareSelectionState(grouped);
            renderResultsList(grouped, detectionList, { showReason: true, withSelection: true });
            updateSelectAllUi();
            showSelectAllControls(true);
            obfuscateButton.disabled = false;
            activeRedactions = [];
            var total = grouped.reduce(function (acc, item) {
              return acc + (item.entries ? item.entries.length : 0);
            }, 0);
            var note = aiData.model ? " (modelo " + aiData.model + ")" : "";
            detectionSummary.textContent = "La IA confirmo " + total + " posible(s) dato(s) sensible(s)" + note + ".";
            detectionSummary.dataset.baseMessage = detectionSummary.textContent;
            applyHighlights(grouped, { redactionTerms: [] });
            return;
          }
          detectionSummary.textContent = "La IA no identifico datos sensibles en el documento.";
          detectionList.innerHTML = '<li class="detection-empty">Sin coincidencias confirmadas por IA.</li>';
          activeRedactions = [];
          clearSelections();
          showSelectAllControls(false);
          obfuscateButton.disabled = true;
          applyHighlights(null);
        })
        .catch(function (err) {
          console.error(err);
          detectionSummary.textContent = "Fallo la validacion con IA (" + err.message + "). Se muestran coincidencias basicas.";
          detectionSummary.dataset.baseMessage = detectionSummary.textContent;
          prepareSelectionState(groups);
          renderResultsList(groups, detectionList, { showReason: false, withSelection: true });
          updateSelectAllUi();
          showSelectAllControls(true);
          obfuscateButton.disabled = false;
          activeRedactions = [];
          applyHighlights(groups, { redactionTerms: [] });
        });
    }

    function callAiValidation(fullText, groups) {
      var flattened = [];
      groups.forEach(function (group) {
        if (!group || !group.entries) { return; }
        group.entries.forEach(function (entry) {
          if (!entry || !entry.value) { return; }
          flattened.push({ label: group.label, value: entry.value });
        });
      });
      if (!flattened.length) {
        return Promise.resolve({ sensitive: [] });
      }
      var headers = { "Content-Type": "application/json" };
      var token = getCsrfToken();
      if (token) {
        headers["X-CSRFToken"] = token;
      }
      return fetch("/api/pdf/analyze", {
        method: "POST",
        credentials: "same-origin",
        headers: headers,
        body: JSON.stringify({
          text: fullText,
          candidates: flattened
        })
      }).then(function (response) {
        return response.text().then(function (bodyText) {
          var data = {};
          if (bodyText) {
            try {
              data = JSON.parse(bodyText);
            } catch (err) {
              throw new Error("No se pudo interpretar la respuesta del analizador.");
            }
          }
          if (!response.ok || !data.ok) {
            var message = data && data.error ? data.error : ("Error " + response.status);
            throw new Error(message);
          }
          return data;
        });
      });
    }

    function collectCandidateGroups(text) {
      var detectors = [
        {
          label: "Telefonos",
          regex: function () { return /\b(?:\+?\d{2,3}[\s.-]?)?(?:\d[\s.-]?){9,12}\b/g; },
          filter: function (value) {
            return value.replace(/\D/g, "").length >= 9;
          }
        },
        {
          label: "Emails",
          regex: function () { return /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi; }
        },
        {
          label: "Nombres completos",
          regex: function () { return /\b(?:[A-Z\u00C0-\u017F][a-z\u00C0-\u017F]+(?:\s+[A-Z\u00C0-\u017F][a-z\u00C0-\u017F]+){1,3})\b/g; },
          filter: function (value) {
            return value.split(/\s+/).length >= 2;
          }
        },
        {
          label: "Direcciones",
          regex: function () { return /\b(?:calle|c\/|avenida|av\.?|paseo|plaza|camino|carretera)\s+[A-Z\u00C0-\u017Fa-z\u00C0-\u017F0-9\s.,-]{3,60}\b/gi; }
        },
        {
          label: "Codigos postales",
          regex: function () { return /\b\d{5}\b/g; }
        },
        {
          label: "Cuentas Bancarias / IBAN",
          regex: function () { return /\b([a-zA-Z]{2}\d{2}\s?)(\d{4}\s?){4,6}\b|\b\d{4}\s?\d{4}\s?\d{2}\s?\d{10}\b/g; },
          filter: function (value) {
            var clean = value.replace(/[\s-]/g, "");
            // Minimo longitud de CCC (20) o IBAN con ES (22)
            return clean.length >= 20;
          }
        },
        {
          label: "Nombres de Bancos",
          regex: function () { return /\b(?:Banco|Banc|Caixa|Caja|ING|BBVA|Santander|Sabadell|Kutxabank|Bankinter|Openbank|N26|Revolut)\s?[\w\.]*\b/gi; }
        },
        {
          label: "Datos Sociales",
          regex: function () { return /\b(?:Tarifa|Bono)\s(?:Social|Vulnerable)\b|\bVulnerabilidad\b/gi; }
        }
      ];

      var groups = [];
      detectors.forEach(function (det) {
        var matches = collectMatches(det.regex, text, det.filter);
        if (matches.length) {
          groups.push({
            label: det.label,
            entries: matches.map(function (value) {
              return { value: value };
            })
          });
        }
      });
      return groups;
    }

    function groupByLabel(items) {
      var grouped = Object.create(null);
      items.forEach(function (item) {
        if (!item || !item.label || !item.value) { return; }
        if (!grouped[item.label]) {
          grouped[item.label] = [];
        }
        grouped[item.label].push({
          value: item.value,
          reason: item.reason || "",
          confidence: item.confidence || ""
        });
      });
      return Object.keys(grouped).map(function (label) {
        return { label: label, entries: grouped[label] };
      });
    }

    // Filter State
    var currentFilter = 'all'; // all, high, medium

    function setupFilterListeners() {
      var buttons = document.querySelectorAll('#confidence-filters button');
      buttons.forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          // Update Active State
          buttons.forEach(function (b) { b.classList.remove('btn-active'); });
          e.target.classList.add('btn-active');

          // Update Filter
          currentFilter = e.target.dataset.filter || 'all';

          // Re-render
          if (latestFindings) {
            renderResultsList(latestFindings, detectionList, { showReason: true, withSelection: true });
            updateSelectAllUi();
          }
        });
      });
    }
    // Initialize
    setupFilterListeners();

    function renderResultsList(groups, listEl, options) {
      if (!groups || !groups.length) {
        listEl.innerHTML = '<li class="detection-empty">Sin coincidencias.</li>';
        return;
      }
      var maxPerLabel = options && options.maxPerLabel ? options.maxPerLabel : 10;
      var showReason = !!(options && options.showReason);
      var withSelection = options && Object.prototype.hasOwnProperty.call(options, "withSelection") ? !!options.withSelection : true;

      var html = groups.map(function (group) {
        var safeLabel = escapeHtml(group.label || "");

        // Filter logic
        var entries = group.entries || [];
        if (currentFilter !== 'all') {
          entries = entries.filter(function (e) {
            var conf = (e.confidence || "low").toLowerCase();
            if (currentFilter === 'high') return conf === 'high';
            if (currentFilter === 'medium') return conf === 'high' || conf === 'medium';
            return true;
          });
        }

        if (!entries.length) return ""; // Skip empty groups

        entries = entries.slice(0, maxPerLabel);

        var valuesHtml = entries.map(function (entry) {
          var details = [];
          if (showReason && entry.reason) {
            details.push(entry.reason);
          }
          if (showReason && entry.confidence) {
            details.push("Confianza: " + entry.confidence);
          }
          var detailHtml = details.length ? '<div class="detection-reason">' + escapeHtml(details.join(". ")) + '</div>' : "";
          var valueText = entry && entry.value ? entry.value : "";
          if (withSelection) {
            var key = buildEntryKey(group.label || "", valueText);
            var entryState = selectionState[key];
            var isChecked = entryState ? !!entryState.selected : false;
            // Si el elemento está oculto por filtro, no deberíamos renderizarlo, pero aquí ya hemos filtrado 'entries'.
            // Sin embargo, hay que asegurar que la selección se mantiene coherente.
            var checkedAttr = isChecked ? " checked" : "";
            return '<label class="detection-option"><input type="checkbox" class="detection-checkbox" data-entry-key="' + escapeHtml(key) + '"' + checkedAttr + ' /><span>' + escapeHtml(valueText) + detailHtml + '</span></label>';
          }
          return '<div>' + escapeHtml(valueText) + detailHtml + '</div>';
        }).join("");
        return '<li><div class="detection-item"><span class="detection-tag">' + safeLabel + '</span><div class="detection-values">' + valuesHtml + '</div></div></li>';
      }).join("");

      if (!html) {
        listEl.innerHTML = '<li class="detection-empty">No hay resultados con este filtro.</li>';
      } else {
        listEl.innerHTML = html;
      }
    }

    function prepareSelectionState(groups) {
      selectionState = Object.create(null);
      if (!groups || !groups.length) { return; }
      groups.forEach(function (group) {
        if (!group || !group.entries) { return; }
        group.entries.forEach(function (entry) {
          if (!entry || !entry.value) { return; }
          var key = buildEntryKey(group.label || "", entry.value);
          selectionState[key] = {
            label: group.label || "",
            value: (entry.value || "").trim(),
            selected: true
          };
        });
      });
    }

    function clearSelections() {
      selectionState = Object.create(null);
      detectionList.querySelectorAll('input[data-entry-key]').forEach(function (input) {
        input.checked = false;
      });
      if (selectAllCheckbox) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
      }
      if (selectAllContainer) {
        selectAllContainer.classList.add("is-hidden");
      }
      if (detectionSummary && detectionSummary.dataset) {
        delete detectionSummary.dataset.baseMessage;
      }
    }

    function updateSelectAllUi() {
      if (!selectAllCheckbox) { return; }
      var keys = Object.keys(selectionState);
      if (!keys.length) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
        return;
      }
      var selectedCount = 0;
      keys.forEach(function (key) {
        var entry = selectionState[key];
        if (entry && entry.selected) {
          selectedCount++;
        }
      });
      if (selectedCount === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
      } else if (selectedCount === keys.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
      } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
      }
    }

    function showSelectAllControls(show) {
      if (!selectAllContainer) { return; }
      if (show) {
        selectAllContainer.classList.remove("is-hidden");
      } else {
        selectAllContainer.classList.add("is-hidden");
      }
    }

    function showDebugInfo(traces) {
      if (!debugContainer || !debugContent) return;
      if (!traces || !traces.length) {
        debugContainer.style.display = "none";
        debugContent.innerHTML = "";
        return;
      }
      debugContainer.style.display = "block";
      var html = traces.map(function (t, idx) {
        var err = t.error ? ('<span style="color:#f87171">ERROR: ' + escapeHtml(t.error) + '</span>\n') : '';
        return '<strong>[' + idx + '] ' + escapeHtml(t.model || "?") + ' - ' + escapeHtml(t.timestamp || "") + '</strong>\n' +
          err +
          '--- SYSTEM PROMPT ---\n' + escapeHtml(t.input_system || "") + '\n\n' +
          '--- USER PROMPT ---\n' + escapeHtml(t.input_user || "") + '\n\n' +
          '--- OUTPUT RAW ---\n' + escapeHtml(t.output_raw || "<empty>") + '\n\n' +
          '========================================\n\n';
      }).join("");
      debugContent.innerHTML = html;
    }

    function buildEntryKey(label, value) {
      return encodeURIComponent(label || "") + "::" + encodeURIComponent(value || "");
    }

    function decodeEntryKey(key) {
      if (!key) { return { label: "", value: "" }; }
      var parts = key.split("::");
      var label = "";
      var value = "";
      if (parts.length) {
        try {
          label = decodeURIComponent(parts[0] || "");
        } catch (err) {
          label = parts[0] || "";
        }
        if (parts.length > 1) {
          try {
            value = decodeURIComponent(parts.slice(1).join("::"));
          } catch (error) {
            value = parts.slice(1).join("::");
          }
        }
      }
      return { label: label, value: value };
    }

    function getSelectedValues() {
      var values = [];
      var seen = Object.create(null);
      Object.keys(selectionState).forEach(function (key) {
        var entry = selectionState[key];
        if (!entry || !entry.selected) { return; }
        var value = entry.value ? entry.value.trim() : "";
        if (value) {
          var normalized = normalizeTerm(value);
          if (!seen[normalized]) {
            seen[normalized] = true;
            values.push(value);
          }
        }
      });
      return values;
    }

    function getCsrfToken() {
      return csrfMeta ? csrfMeta.getAttribute("content") : null;
    }

    function isPdfFile(file) {
      var name = file && file.name ? file.name : "";
      return file && (file.type === "application/pdf" || /\.pdf$/i.test(name));
    }

    function resetViewer() {
      if (renderer) {
        renderer.innerHTML = "";
        renderer.classList.remove("is-visible");
        renderer.scrollTop = 0;
      }
      if (placeholder) {
        placeholder.classList.remove("is-hidden");
      }
      container.classList.remove("has-file");
      renderedPages = [];
      latestFindings = null;
      activeRedactions = [];
    }

    function destroyCurrentPdf() {
      if (currentPdfDoc && typeof currentPdfDoc.destroy === "function") {
        try { currentPdfDoc.destroy(); } catch (err) { console.warn(err); }
      }
      currentPdfDoc = null;
    }

    function renderPdfDocument(uint8) {
      if (!renderer) {
        return Promise.resolve();
      }
      resetViewer();
      return ensurePdfJs().then(function (pdfjs) {
        return pdfjs.getDocument({ data: uint8 }).promise.then(function (doc) {
          destroyCurrentPdf();
          currentPdfDoc = doc;
          var totalPages = doc.numPages;
          renderedPages = new Array(totalPages);
          var renderTasks = [];

          for (var pageNumber = 1; pageNumber <= totalPages; pageNumber++) {
            renderTasks.push(
              doc.getPage(pageNumber).then(function (page) {
                var viewport = page.getViewport({ scale: 1.3 });
                var wrapper = document.createElement("div");
                wrapper.className = "pdf-page-render";
                wrapper.style.width = viewport.width + "px";
                wrapper.style.height = viewport.height + "px";

                var canvas = document.createElement("canvas");
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.className = "pdf-canvas";
                wrapper.appendChild(canvas);

                var textLayer = document.createElement("div");
                textLayer.className = "pdf-text-layer";
                textLayer.style.width = viewport.width + "px";
                textLayer.style.height = viewport.height + "px";
                wrapper.appendChild(textLayer);

                renderer.appendChild(wrapper);

                var canvasContext = canvas.getContext("2d");
                var renderTask = page.render({ canvasContext: canvasContext, viewport: viewport });

                var textDivs = [];
                var textLayerTask = page.getTextContent().then(function (textContent) {
                  return pdfjs.renderTextLayer({
                    textContent: textContent,
                    container: textLayer,
                    viewport: viewport,
                    textDivs: textDivs,
                    enhanceTextSelection: false
                  }).promise.then(function () {
                    textDivs.forEach(function (div) {
                      div.dataset.rawText = div.textContent || "";
                    });
                    renderedPages[page.pageNumber - 1] = { textDivs: textDivs };
                  });
                });

                return Promise.all([renderTask.promise, textLayerTask]);
              })
            );
          }

          return Promise.all(renderTasks).then(function () {
            renderer.classList.add("is-visible");
            renderer.scrollTop = 0;
            container.classList.add("has-file");
            if (placeholder) {
              placeholder.classList.add("is-hidden");
            }
            if (latestFindings) {
              applyHighlights(latestFindings);
            } else {
              applyHighlights(null);
            }
          });
        });
      });
    }

    function ensurePdfJs() {
      if (window.pdfjsLib) {
        configurePdfWorker();
        return Promise.resolve(window.pdfjsLib);
      }
      if (!pdfLoaderPromise) {
        pdfLoaderPromise = new Promise(function (resolve, reject) {
          var triedFallback = false;
          function loadScript(src, workerSrc) {
            var script = document.createElement("script");
            script.src = src;
            script.async = true;
            script.onload = function () {
              if (window.pdfjsLib) {
                activeWorkerSrc = workerSrc;
                configurePdfWorker();
                resolve(window.pdfjsLib);
              } else if (!triedFallback && PDFJS_FALLBACK_SRC) {
                triedFallback = true;
                loadScript(PDFJS_FALLBACK_SRC, PDFJS_FALLBACK_WORKER_SRC);
              } else {
                reject(new Error("No se pudo cargar el analizador de PDF. Revisa tu conexion."));
              }
            };
            script.onerror = function () {
              if (!triedFallback && PDFJS_FALLBACK_SRC) {
                triedFallback = true;
                loadScript(PDFJS_FALLBACK_SRC, PDFJS_FALLBACK_WORKER_SRC);
              } else {
                reject(new Error("No se pudo cargar el analizador de PDF. Revisa tu conexion."));
              }
            };
            document.head.appendChild(script);
          }
          loadScript(PDFJS_SRC, PDFJS_WORKER_SRC);
        });
        pdfLoaderPromise.catch(function () {
          pdfLoaderPromise = null;
        });
      }
      return pdfLoaderPromise;
    }

    function configurePdfWorker() {
      if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = activeWorkerSrc;
      }
    }

    function readFileAsArrayBuffer(file) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function (evt) {
          resolve(new Uint8Array(evt.target.result));
        };
        reader.onerror = function () {
          reject(new Error("No se pudo leer el archivo PDF."));
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function collectMatches(regexFactory, text, filter) {
      var regex = regexFactory();
      var output = [];
      var seen = Object.create(null);
      var match;
      while ((match = regex.exec(text)) !== null) {
        var value = (match[0] || "").trim();
        if (!value) { continue; }
        if (filter && !filter(value)) { continue; }
        var key = value.toLowerCase();
        if (!seen[key]) {
          seen[key] = true;
          output.push(value);
        }
      }
      return output;
    }

    function applyHighlights(findings, options) {
      latestFindings = findings && findings.length ? findings : null;
      if (!latestFindings) {
        activeRedactions = [];
      }
      if (options && Object.prototype.hasOwnProperty.call(options, "redactionTerms")) {
        activeRedactions = Array.isArray(options.redactionTerms) ? options.redactionTerms.slice() : [];
      }
      var terms = extractHighlightTerms(latestFindings);
      var redactionLookup = createRedactionLookup(activeRedactions);
      renderedPages.forEach(function (page) {
        if (!page || !page.textDivs) { return; }
        page.textDivs.forEach(function (div) {
          var original = div.dataset && typeof div.dataset.rawText === "string" ? div.dataset.rawText : (div.textContent || "");
          if (!terms.length) {
            if (div.textContent !== original) {
              div.textContent = original;
            }
            return;
          }
          var highlighted = buildHighlightedHtml(original, terms, redactionLookup);
          if (highlighted.changed) {
            div.innerHTML = highlighted.html;
          } else if (div.textContent !== original) {
            div.textContent = original;
          }
        });
      });
    }

    function extractHighlightTerms(findings) {
      if (!findings || !findings.length) {
        return [];
      }
      var seen = Object.create(null);
      var terms = [];
      findings.forEach(function (group) {
        if (!group || !group.entries) { return; }
        group.entries.forEach(function (entry) {
          var term = entry && entry.value ? entry.value.trim() : "";
          if (!term) { return; }
          var key = term.toLowerCase();
          if (!seen[key]) {
            seen[key] = true;
            terms.push(term);
          }
        });
      });
      return terms;
    }

    function buildHighlightedHtml(text, terms, redactionLookup) {
      if (!terms.length) {
        return { html: escapeHtml(text), changed: false };
      }
      var escapedTerms = [];
      for (var i = 0; i < terms.length; i++) {
        var term = terms[i];
        if (term) {
          escapedTerms.push(escapeRegExp(term));
        }
      }
      if (!escapedTerms.length) {
        return { html: escapeHtml(text), changed: false };
      }
      var pattern = new RegExp("(" + escapedTerms.join("|") + ")", "gi");
      var match;
      var lastIndex = 0;
      var pieces = [];
      var changed = false;
      while ((match = pattern.exec(text)) !== null) {
        var index = match.index;
        if (index > lastIndex) {
          pieces.push(escapeHtml(text.slice(lastIndex, index)));
        }
        var matchText = match[0];
        var normalized = normalizeTerm(matchText);
        var classNames = "pdf-highlight";
        if (redactionLookup && redactionLookup[normalized]) {
          classNames += " pdf-redaction";
        }
        pieces.push('<span class="' + classNames + '">' + escapeHtml(matchText) + '</span>');
        lastIndex = index + match[0].length;
        changed = true;
      }
      if (!changed) {
        return { html: escapeHtml(text), changed: false };
      }
      if (lastIndex < text.length) {
        pieces.push(escapeHtml(text.slice(lastIndex)));
      }
      return { html: pieces.join(""), changed: true };
    }

    function createRedactionLookup(terms) {
      var lookup = Object.create(null);
      if (!terms || !terms.length) {
        return lookup;
      }
      for (var i = 0; i < terms.length; i++) {
        var normalized = normalizeTerm(terms[i]);
        if (normalized) {
          lookup[normalized] = true;
        }
      }
      return lookup;
    }

    function normalizeTerm(value) {
      if (value === null || value === undefined) { return ""; }
      return String(value).trim().toLowerCase();
    }

    function escapeRegExp(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeHtml(value) {
      return value.replace(/[&<>"']/g, function (ch) {
        switch (ch) {
          case "&": return "&amp;";
          case "<": return "&lt;";
          case ">": return "&gt;";
          case '"': return "&quot;";
          case "'": return "&#39;";
          default: return ch;
        }
      });
    }
  })();
</script>

{% endblock %}